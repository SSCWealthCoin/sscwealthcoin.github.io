<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SSCWC Chess Minimal Test</title>
<style>
  body { margin:0; font-family:sans-serif; background:#000; color:#fff; display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:100vh; }
  #board { display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr); width:480px; aspect-ratio:1/1; border:4px solid #ffd700; }
  .square { display:flex; align-items:center; justify-content:center; font-size:2rem; cursor:pointer; }
  .light { background:#f9d98b; }
  .dark { background:#946b32; }
  .white-piece { color:#fff; text-shadow:0 0 6px #d4af37; }
  .black-piece { color:#111; text-shadow:0 0 6px rgba(0,0,0,0.6); }
  .highlight { outline:3px solid rgba(255,255,255,0.2); }
  .move-dot { width:10px; height:10px; border-radius:50%; background:rgba(0,0,0,0.5); }
  #status { margin:12px; color:#bdf7b8; font-weight:bold; }
</style>
</head>
<body>

<div id="board"></div>
<div id="status">Your move — play White.</div>

<script type="module">
const unicodeMap = {'P':'♙','R':'♖','N':'♘','B':'♗','Q':'♕','K':'♔',
                    'p':'♟','r':'♜','n':'♞','b':'♝','q':'♛','k':'♚'};

let boardState = [
  ['r','n','b','q','k','b','n','r'],
  ['p','p','p','p','p','p','p','p'],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['','','','','','','',''],
  ['P','P','P','P','P','P','P','P'],
  ['R','N','B','Q','K','B','N','R']
];

let whiteToMove = true;
let selected = null;
let legalMovesCache = [];
let castlingRights = {white:{K:true,Q:true}, black:{K:true,Q:true}};
let enPassantTarget = null;

const boardEl = document.getElementById('board');

function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function cloneBoard(b){ return b.map(row => row.slice()); }

function coordToIndex(r,c){ return r*8+c; }

function findKing(b,white){ for(let r=0;r<8;r++) for(let c=0;c<8;c++) if(b[r][c]=== (white?'K':'k')) return [r,c]; return null; }
function isSquareAttacked(b,sr,sc,byWhite){
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p = b[r][c]; if(!p) continue; const isWhite = (p===p.toUpperCase()); if(isWhite!==byWhite) continue;
    const piece = p.toLowerCase(); const dr=sr-r, dc=sc-c;
    if(piece==='p'){ const dir=isWhite?-1:1; if(sr===r+dir && Math.abs(dc)===1) return true; }
    else if(piece==='n'){ if((Math.abs(dr)===2 && Math.abs(dc)===1)||(Math.abs(dr)===1 && Math.abs(dc)===2)) return true; }
    else if(piece==='b'||piece==='q'){ if(Math.abs(dr)===Math.abs(dc) && dr!==0){ let stepR=dr/Math.abs(dr), stepC=dc/Math.abs(dc), blocked=false; let rr=r+stepR,cc=c+stepC; while(rr!==sr||cc!==sc){ if(b[Math.round(rr)][Math.round(cc)]){blocked=true;break;} rr+=stepR; cc+=stepC;} if(!blocked) return true; } }
    else if(piece==='r'||piece==='q'){ if(dr===0||dc===0){ let stepR=dr===0?0:dr/Math.abs(dr), stepC=dc===0?0:dc/Math.abs(dc), blocked=false; let rr=r+stepR,cc=c+stepC; while(rr!==sr||cc!==sc){ if(b[Math.round(rr)][Math.round(cc)]){blocked=true;break;} rr+=stepR; cc+=stepC;} if(!blocked) return true; } }
    else if(piece==='k'){ if(Math.max(Math.abs(dr),Math.abs(dc))===1) return true; }
  }
  return false;
}
function isKingInCheck(b,white){ const king=findKing(b,white); if(!king)return true; return isSquareAttacked(b,king[0],king[1],!white); }

function generateMoves(b,whiteTurn){
  const moves=[];
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p=b[r][c]; if(!p) continue; const isWhite = (p===p.toUpperCase()); if(isWhite!==whiteTurn) continue;
    const piece=p.toLowerCase();
    if(piece==='p'){ const dir=isWhite?-1:1, startRow=isWhite?6:1;
      if(inBounds(r+dir,c) && !b[r+dir][c]) moves.push({from:[r,c],to:[r+dir,c],promote:(r+dir===0||r+dir===7)});
      if(r===startRow && inBounds(r+2*dir,c) && !b[r+dir][c] && !b[r+2*dir][c]) moves.push({from:[r,c],to:[r+2*dir,c],double:true});
      for(const dc of [-1,1]){ const nr=r+dir,nc=c+dc; if(inBounds(nr,nc)){ const occ=b[nr][nc]; if(occ){ const occWhite = (occ===occ.toUpperCase()); if(occWhite!==isWhite) moves.push({from:[r,c],to:[nr,nc],capture:true,promote:(nr===0||nr===7)}); } else if(enPassantTarget && enPassantTarget[0]===nr && enPassantTarget[1]===nc) moves.push({from:[r,c],to:[nr,nc],enPassant:true,capture:true}); } } }
    } else if(piece==='n'){ [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr,dc])=>{ let nr=r+dr,nc=c+dc; if(inBounds(nr,nc)){ const occ=b[nr][nc]; if(!occ || (occ.toUpperCase()!==p.toUpperCase())) moves.push({from:[r,c],to:[nr,nc],capture:!!occ}); } }); }
    else if(piece==='b'||piece==='r'||piece==='q'){
      const directions=[]; if(piece==='b'||piece==='q') directions.push([-1,-1],[-1,1],[1,-1],[1,1]); if(piece==='r'||piece==='q') directions.push([-1,0],[1,0],[0,-1],[0,1]);
      directions.forEach(([dr,dc])=>{ let nr=r+dr,nc=c+dc; while(inBounds(nr,nc
