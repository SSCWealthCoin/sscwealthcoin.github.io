<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSCWC Chess Crypto Kings â€” Matchmaking & Coach</title>
  <style>
    /* Reset + basics */
    * { box-sizing: border-box; }
    html,body { height:100%; }
    body {
      margin: 0;
      font-family: "Poppins", sans-serif;
      background: #000;
      color: #fff;
      text-align: center;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      padding: 14px;
    }

    .logo-container { margin-top: 16px; display:flex; justify-content:center; align-items:center; }
    .logo-container img { width: 120px; max-width: 28vw; border-radius: 50%; box-shadow: 0 0 60px rgba(255, 215, 0, 0.6); }

    h1 { font-size: 1.6em; color: #ffd700; margin-top: 12px; margin-bottom: 6px; }
    h2 { font-size: 1.05em; font-style: italic; color: #ffe066; margin-bottom: 12px; }

    .controls { margin-bottom: 8px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
    .btn { padding: 10px 14px; margin: 4px; border: none; border-radius: 10px; cursor: pointer; font-size: 0.95em; font-weight: 600; transition: transform 0.12s ease, box-shadow 0.12s ease; }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.4); }
    .btn-pink { background: #ff42e3; color: white; }
    .btn-blue { background: #007bff; color: white; }
    .btn-green { background: #00b853; color: white; }
    .btn-gold { background: linear-gradient(180deg, #ffea70 0%, #ffcc00 100%); color: #000; font-weight: bold; box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }

    input[type="email"] { padding: 10px; width: 300px; max-width: 76vw; border-radius: 8px; border: 1px solid #333; margin: 6px 0; background: #111; color: #fff; text-align: center; }

    #status { color: #ccc; font-size: 0.95rem; margin-top: 8px; min-height: 1.1em; }

    /* Responsive chess container */
    #chessContainer { margin: 18px auto; width: min(480px, 92vw); display:flex; justify-content:center; align-items:center; padding: 10px; border-radius: 10px; background: radial-gradient(circle at center, #111 60%, #000 100%); border: 2px solid #ffd700; box-shadow: 0 0 40px rgba(255, 215, 0, 0.22); }

    #board { width: 100%; aspect-ratio: 1 / 1; display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); border: 4px solid #ffd700; box-shadow: 0 0 22px rgba(255, 215, 0, 0.24); position: relative; user-select: none; max-width: 480px; }

    .square { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: calc(18px + 1.7vmin); cursor: pointer; padding: 0; margin: 0; }
    .light { background-color: #f9d98b; }
    .dark  { background-color: #946b32; }

    .white-piece { color: #fff; text-shadow: 0 0 6px #d4af37; font-weight: 800; }
    .black-piece { color: #111; text-shadow: 0 0 6px rgba(0,0,0,0.6); font-weight: 800; }

    .highlight { outline: 3px solid rgba(255,255,255,0.18); box-shadow: inset 0 0 8px rgba(255,255,255,0.06); }
    .move-dot { width: 10px; height: 10px; border-radius: 50%; background: rgba(0,0,0,0.5); box-shadow: 0 0 6px rgba(0,0,0,0.3); }

    footer { margin: 12px 0; color: #777; font-size: 0.86em; }

    /* Coach popup (Gold & Black theme - Option A) */
    .coach-modal, .profile-modal, .matchmaking-modal { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 9999; }
    .coach-card, .profile-card, .matchmaking-card { width: min(720px, 94vw); max-width: 920px; background: linear-gradient(180deg, rgba(10,10,10,0.98), rgba(22,16,10,0.98)); border-radius: 14px; padding: 18px; box-shadow: 0 10px 60px rgba(0,0,0,0.8), 0 0 40px rgba(255,215,0,0.12); border: 2px solid rgba(255,215,0,0.16); color: #fff; }
    .coach-header { display:flex; gap:12px; align-items:center; }
    .coach-title { color:#ffd700; font-weight:800; font-size:1.2rem; }
    .coach-body { margin-top:12px; text-align:left; color:#fff; }
    .coach-actions { margin-top:14px; display:flex; gap:8px; justify-content:flex-end; }
    .close-x { background:transparent; border:1px solid rgba(255,215,0,0.18); color:#ffd700; padding:6px 8px; border-radius:8px; cursor:pointer; }

    /* Profile Dashboard tabs */
    .tabs { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
    .tab { padding:8px 10px; border-radius:10px; background: rgba(255,215,0,0.06); color:#ffd700; cursor:pointer; }
    .tab.active { background: linear-gradient(90deg,#ffd700,#ffea70); color:#000; font-weight:700; }
    .tab-panel { margin-top:12px; text-align:left; background: rgba(255,255,255,0.02); padding:12px; border-radius:8px; max-height:46vh; overflow:auto; }

    .small { font-size:0.85rem; color:#ddd; }

    @media (max-width: 480px) { .logo-container img { width: 96px; } h1 { font-size: 1.3em; } .controls { gap:6px; } .coach-card{ width: 94vw; padding:12px; } }
  </style>
</head>
<body>
  <div class="logo-container">
    <img src="https://raw.githubusercontent.com/SSCWealthCoin/sscwealthcoin.github.io/main/Gifcmr3XoAA_WF-.jpeg" alt="SSC Wealth Coin Logo">
  </div>

  <h1>SSCWC Chess Crypto Kings</h1>
  <h2>The Future of Gold on Blockchain</h2>

  <input id="emailInput" type="email" placeholder="Your email (for quick sign-in)" />
  <div>
    <button id="sendLinkBtn" class="btn btn-pink">Send Magic Link</button>
  </div>

  <div class="controls">
    <button id="connectWalletBtn" class="btn btn-blue">Connect Wallet (BSC Testnet)</button>
    <button id="openProfileBtn" class="btn btn-gold">Open Profile Dashboard</button>
    <button id="createGameBtn" class="btn btn-green">Create Game</button>
    <button id="buyBtn" class="btn btn-gold" onclick="window.open('https://app.uniswap.org/explore/tokens/bnb/0xd7deadbf768dec8ac13850e4f6787ac53a9d0447?utm_medium=mobile&utm_source=share-tdp','_blank')">ðŸª™ Buy SSCWC on Uniswap</button>
  </div>

  <div id="status">Initializing...</div>

  <div id="chessContainer">
    <div id="board" aria-label="Chess board" role="grid"></div>
  </div>

  <footer>Â© 2025 SSC Wealth Coin â€” All Rights Reserved</footer>

  <!-- Coach / Profile / Matchmaking modals will be injected by JS -->

  <script type="module">
  /* === PLATFORM UID START === */
  const PLATFORM_UID = "sscwc-v1-global";
  /* === PLATFORM UID END === */


    // Basic safety handlers
    window.addEventListener('error', (ev) => { const st = document.getElementById('status'); st.textContent = 'Error: ' + (ev.error && ev.error.message ? ev.error.message : ev.message); st.style.color = '#ffb3b3'; console.error(ev.error || ev.message); });
    window.addEventListener('unhandledrejection', (ev) => { const st = document.getElementById('status'); st.textContent = 'Unhandled promise rejection: ' + (ev.reason && ev.reason.message ? ev.reason.message : JSON.stringify(ev.reason)); st.style.color = '#ffb3b3'; console.error('unhandledrejection', ev.reason); });

    /* ------------------ Chess core (kept largely as-is) ------------------ */
    const unicodeMap = { 'P': 'â™™','R':'â™–','N':'â™˜','B':'â™—','Q':'â™•','K':'â™”', 'p': 'â™Ÿ','r':'â™œ','n':'â™ž','b':'â™','q':'â™›','k':'â™š' };

    let boardState = [ ['r','n','b','q','k','b','n','r'], ['p','p','p','p','p','p','p','p'], ['','','','','','','',''], ['','','','','','','',''], ['','','','','','','',''], ['','','','','','','',''], ['P','P','P','P','P','P','P','P'], ['R','N','B','Q','K','B','N','R'] ];

    let whiteToMove = true; // user plays white
    let selected = null; let legalMovesCache = [];
    let castlingRights = { white: { K: true, Q: true }, black: { K: true, Q: true } };
    let enPassantTarget = null;

    // Move history & simple stats for coach + matchmaking
    let moveHistory = []; // {from:[r,c],to:[r,c],piece:'P',capture:boolean,castle:null,enPassant:false,promote:false,by:'white'/'black'}
    let aiGamesPlayed = 0; // after 3 trigger matchmaking offer

    const boardEl = document.getElementById('board');
    function coordToIndex(r,c){ return r*8 + c; }
    function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
    function cloneBoard(b){ return b.map(row => row.slice()); }

    // We'll reuse generateMoves / isSquareAttacked / applyMove functions from previous file (omitted here for brevity)
    // For this canvas version we include working implementations (kept similar to source) â€” START

    function generateMoves(b, whiteTurn) {
      const moves = [];
      for (let r=0;r<8;r++){
        for (let c=0;c<8;c++){
          const p = b[r][c]; if (!p) continue; const isWhite = (p === p.toUpperCase()); if (isWhite !== whiteTurn) continue; const piece = p.toLowerCase();
          if (piece === 'p') {
            const dir = isWhite ? -1 : 1; const startRow = isWhite ? 6 : 1;
            if (inBounds(r+dir,c) && !b[r+dir][c]) { moves.push({from:[r,c],to:[r+dir,c],promote: (r+dir===0 || r+dir===7)}); if (r === startRow && inBounds(r+2*dir,c) && !b[r+2*dir][c] && !b[r+dir][c]) moves.push({from:[r,c],to:[r+2*dir,c],double:true}); }
            for (const dc of [-1,1]) { const nr=r+dir, nc=c+dc; if (inBounds(nr,nc)) { if (b[nr][nc]) { const occ = b[nr][nc]; const occWhite = (occ === occ.toUpperCase()); if (occWhite !== isWhite) moves.push({from:[r,c],to:[nr,nc],capture:true,promote:(nr===0||nr===7)}); } else { if (enPassantTarget && enPassantTarget[0] === nr && enPassantTarget[1] === nc) { moves.push({from:[r,c],to:[nr,nc],enPassant:true,capture:true}); } } } }
          } else if (piece === 'n') {
            const del = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]; for (const [dr,dc] of del) { const nr=r+dr, nc=c+dc; if (!inBounds(nr,nc)) continue; const occ=b[nr][nc]; if (!occ || (occ && (occ === occ.toUpperCase()) !== isWhite)) { moves.push({from:[r,c],to:[nr,nc],capture:!!occ}); } }
          } else if (piece === 'b' || piece === 'r' || piece === 'q') {
            const directions = []; if (piece === 'b' || piece === 'q') directions.push([-1,-1],[-1,1],[1,-1],[1,1]); if (piece === 'r' || piece === 'q') directions.push([-1,0],[1,0],[0,-1],[0,1]); for (const [dr,dc] of directions) { let nr=r+dr, nc=c+dc; while (inBounds(nr,nc)) { if (!b[nr][nc]) { moves.push({from:[r,c],to:[nr,nc]}); } else { const occ=b[nr][nc]; const occWhite = (occ === occ.toUpperCase()); if (occWhite !== isWhite) moves.push({from:[r,c],to:[nr,nc],capture:true}); break; } nr += dr; nc += dc; } }
          } else if (piece === 'k') {
            for (let dr=-1;dr<=1;dr++){ for (let dc=-1;dc<=1;dc++){ if (dr===0 && dc===0) continue; const nr=r+dr, nc=c+dc; if (!inBounds(nr,nc)) continue; const occ=b[nr][nc]; if (!occ || (occ && (occ === occ.toUpperCase()) !== isWhite)) { moves.push({from:[r,c],to:[nr,nc],capture:!!occ}); } } }
            if (isWhite && r===7 && c===4) {
              if (castlingRights.white.K && !b[7][5] && !b[7][6] && !isSquareAttacked(b,7,4,false) && !isSquareAttacked(b,7,5,false) && !isSquareAttacked(b,7,6,false) && b[7][7] && b[7][7] === 'R') { moves.push({from:[7,4],to:[7,6],castle:'K'}); }
              if (castlingRights.white.Q && !b[7][3] && !b[7][2] && !b[7][1] && !isSquareAttacked(b,7,4,false) && !isSquareAttacked(b,7,3,false) && !isSquareAttacked(b,7,2,false) && b[7][0] && b[7][0] === 'R') { moves.push({from:[7,4],to:[7,2],castle:'Q'}); }
            }
            if (!isWhite && r===0 && c===4) {
              if (castlingRights.black.K && !b[0][5] && !b[0][6] && !isSquareAttacked(b,0,4,true) && !isSquareAttacked(b,0,5,true) && !isSquareAttacked(b,0,6,true) && b[0][7] && b[0][7] === 'r') { moves.push({from:[0,4],to:[0,6],castle:'K'}); }
              if (castlingRights.black.Q && !b[0][3] && !b[0][2] && !b[0][1] && !isSquareAttacked(b,0,4,true) && !isSquareAttacked(b,0,3,true) && !isSquareAttacked(b,0,2,true) && b[0][0] && b[0][0] === 'r') { moves.push({from:[0,4],to:[0,2],castle:'Q'}); }
            }
          }
        }
      }
      const legal = moves.filter(m => {
        const nb = cloneBoard(b); const [fr,fc] = m.from, [tr,tc] = m.to; let piece = nb[fr][fc]; nb[fr][fc] = '';
        if (m.promote) piece = (piece === piece.toUpperCase()) ? 'Q' : 'q';
        if (m.enPassant) { nb[fr][tc] = ''; }
        if (m.castle === 'K') { nb[tr][tc] = piece; if (tr === 7) { nb[7][5] = nb[7][7]; nb[7][7] = ''; nb[7][4] = ''; } else { nb[0][5] = nb[0][7]; nb[0][7] = ''; nb[0][4] = ''; } }
        else if (m.castle === 'Q') { nb[tr][tc] = piece; if (tr === 7) { nb[7][3] = nb[7][0]; nb[7][0] = ''; nb[7][4] = ''; } else { nb[0][3] = nb[0][0]; nb[0][0] = ''; nb[0][4] = ''; } }
        else { nb[tr][tc] = piece; }
        return !isKingInCheck(nb, whiteTurn);
      });
      return legal;
    }

    function findKing(b, white) { const target = white ? 'K' : 'k'; for (let r=0;r<8;r++) for (let c=0;c<8;c++) if (b[r][c] === target) return [r,c]; return null; }

    function isSquareAttacked(b, sr, sc, byWhite) {
      for (let r=0;r<8;r++){ for (let c=0;c<8;c++){ const p=b[r][c]; if(!p) continue; const isWhite = (p === p.toUpperCase()); if (isWhite !== byWhite) continue; const piece = p.toLowerCase(); const dr = sr - r, dc = sc - c;
        if (piece === 'p') { const dir = isWhite ? -1 : 1; if (sr === r + dir && Math.abs(dc) === 1) return true; }
        else if (piece === 'n') { const adx = Math.abs(dr), ady = Math.abs(dc); if ((adx===1 && ady===2)||(adx===2 && ady===1)) return true; }
        else if (piece === 'b' || piece === 'q') { if (Math.abs(dr) === Math.abs(dc) && dr!==0) { const stepR = dr/Math.abs(dr), stepC = dc/Math.abs(dc); let rr = r+stepR, cc = c+stepC, blocked=false; while (rr !== sr || cc !== sc) { if (b[Math.round(rr)][Math.round(cc)]) { blocked=true; break; } rr += stepR; cc += stepC; } if (!blocked) return true; } }
        if (piece === 'r' || piece === 'q') { if ((dr === 0 && dc !== 0) || (dc === 0 && dr !== 0)) { const stepR = dr === 0 ? 0 : dr/Math.abs(dr); const stepC = dc === 0 ? 0 : dc/Math.abs(dc); let rr = r+stepR, cc = c+stepC, blocked=false; while (rr !== sr || cc !== sc) { if (b[Math.round(rr)][Math.round(cc)]) { blocked=true; break; } rr += stepR; cc += stepC; } if (!blocked) return true; } }
        if (piece === 'k') { if (Math.max(Math.abs(dr),Math.abs(dc)) === 1) return true; }
      } }
      return false;
    }

    function isKingInCheck(b, white) { const kingPos = findKing(b, white); if (!kingPos) return true; const [kr,kc] = kingPos; return isSquareAttacked(b, kr, kc, !white); }

    function applyMove(b, move, actor) {
      const nb = cloneBoard(b); const [fr,fc] = move.from, [tr,tc] = move.to; let piece = nb[fr][fc]; nb[fr][fc] = '';
      if (move.castle === 'K') { nb[tr][tc] = piece; if (tr === 7) { nb[7][5] = nb[7][7]; nb[7][7] = ''; nb[7][4] = ''; } else { nb[0][5] = nb[0][7]; nb[0][7] = ''; nb[0][4] = ''; } if (whiteToMove) { castlingRights.white.K = castlingRights.white.Q = false; } else { castlingRights.black.K = castlingRights.black.Q = false; } enPassantTarget = null; // record
      } else if (move.castle === 'Q') { nb[tr][tc] = piece; if (tr === 7) { nb[7][3] = nb[7][0]; nb[7][0] = ''; nb[7][4] = ''; } else { nb[0][3] = nb[0][0]; nb[0][0] = ''; nb[0][4] = ''; } if (whiteToMove) { castlingRights.white.K = castlingRights.white.Q = false; } else { castlingRights.black.K = castlingRights.black.Q = false; } enPassantTarget = null; } else {
        if (move.enPassant) { nb[fr][tc] = ''; }
        if (move.promote) piece = (piece === piece.toUpperCase()) ? 'Q' : 'q';
        nb[tr][tc] = piece;
        // Update castling rights
        if (piece === 'K') { castlingRights.white.K = false; castlingRights.white.Q = false; }
        if (piece === 'k') { castlingRights.black.K = false; castlingRights.black.Q = false; }
        if (piece === 'R' && fr === 7 && fc === 0) castlingRights.white.Q = false;
        if (piece === 'R' && fr === 7 && fc === 7) castlingRights.white.K = false;
        if (piece === 'r' && fr === 0 && fc === 0) castlingRights.black.Q = false;
        if (piece === 'r' && fr === 0 && fc === 7) castlingRights.black.K = false;
        if (piece.toLowerCase() === 'p' && Math.abs(tr - fr) === 2) { enPassantTarget = [ (fr + tr) / 2, fc ]; } else { enPassantTarget = null; }
      }

      // Save move into history for coach
      moveHistory.push({ from: move.from, to: move.to, piece: piece, capture: !!move.capture, castle: move.castle||null, enPassant: !!move.enPassant, promote: !!move.promote, by: (actor|| (whiteToMove? 'white':'black')) });
      return nb;
    }

    // ---------------- AI (lightweight) ----------------
    const pieceValue = {'p':100,'n':320,'b':330,'r':500,'q':900,'k':20000};
    function evaluate(b) { let score = 0; for (let r=0;r<8;r++){ for (let c=0;c<8;c++){ const p = b[r][c]; if (!p) continue; const isWhite = (p === p.toUpperCase()); const val = pieceValue[p.toLowerCase()] || 0; score += (isWhite ? 1 : -1) * val; } } try { score += 0.1 * (generateMoves(b, true).length - generateMoves(b, false).length); } catch(e){} return score; }

    function minimax(b, depth, alpha, beta, maximizingPlayer) {
      const white = maximizingPlayer;
      if (depth === 0) { return {score: evaluate(b), move: null}; }
      const moves = generateMoves(b, white);
      if (moves.length === 0) { const inCheck = isKingInCheck(b, white); return {score: inCheck ? (white ? -99999 : 99999) : 0, move: null}; }
      let bestMove = null;
      if (maximizingPlayer) {
        let value = -Infinity; moves.sort((a,b)=> (b.capture?1:0) - (a.capture?1:0));
        for (const m of moves) { const nb = applyMove(b,m); const savedEP = enPassantTarget; const savedCastling = JSON.parse(JSON.stringify(castlingRights)); const savedBoard = boardState; boardState = nb; const result = minimax(nb, depth-1, alpha, beta, !maximizingPlayer); boardState = savedBoard; enPassantTarget = savedEP; castlingRights = savedCastling; if (result.score > value) { value = result.score; bestMove = m; } alpha = Math.max(alpha, value); if (alpha >= beta) break; }
        return {score: value, move: bestMove};
      } else {
        let value = Infinity; moves.sort((a,b)=> (a.capture?1:0) - (b.capture?1:0));
        for (const m of moves) { const nb = applyMove(b,m); const savedEP = enPassantTarget; const savedCastling = JSON.parse(JSON.stringify(castlingRights)); const savedBoard = boardState; boardState = nb; const result = minimax(nb, depth-1, alpha, beta, !maximizingPlayer); boardState = savedBoard; enPassantTarget = savedEP; castlingRights = savedCastling; if (result.score < value) { value = result.score; bestMove = m; } beta = Math.min(beta, value); if (alpha >= beta) break; }
        return {score: value, move: bestMove};
      }
    }

    function getAIMove(b, whiteSide) { const depth = 3; const res = minimax(b, depth, -Infinity, Infinity, whiteSide); return res.move; }

    async function runAIMove() {
      const statusEl = document.getElementById('status'); statusEl.textContent = 'AI is thinking...'; await new Promise(res=>setTimeout(res, 120));
      const aiMove = getAIMove(boardState, false); if (!aiMove) { const inCheck = isKingInCheck(boardState, !whiteToMove); statusEl.textContent = inCheck ? 'Checkmate!' : 'Stalemate'; // show coach feedback for game end
        showCoachFeedback(); return; }
      boardState = applyMove(boardState, aiMove, 'black'); whiteToMove = !whiteToMove; renderBoard(); statusEl.textContent = 'Your move';
    }

    /* ------------------ UI Rendering + Interaction ------------------ */
    function renderBoard() { boardEl.innerHTML = ''; for (let r=0;r<8;r++){ for (let c=0;c<8;c++){ const sq = document.createElement('div'); sq.className = 'square ' + (((r+c)%2===0) ? 'light' : 'dark'); sq.dataset.r = r; sq.dataset.c = c; const p = boardState[r][c]; if (p) { const span = document.createElement('span'); span.textContent = unicodeMap[p] || ''; span.className = (p === p.toUpperCase()) ? 'white-piece' : 'black-piece'; sq.appendChild(span); } sq.addEventListener('click', onSquareClick); boardEl.appendChild(sq); } } }

    function clearHighlights() { Array.from(boardEl.children).forEach(ch => { ch.classList.remove('highlight'); const dot = ch.querySelector('.move-dot'); if (dot) dot.remove(); }); }
    function highlightMoves(moves) { for (const m of moves) { const [tr,tc] = m.to; const idx = coordToIndex(tr,tc); const cell = boardEl.children[idx]; if (!cell) continue; cell.classList.add('highlight'); const dot = document.createElement('div'); dot.className = 'move-dot'; cell.appendChild(dot); } }

    function onSquareClick(e) {
      const r = parseInt(this.dataset.r,10); const c = parseInt(this.dataset.c,10); const piece = boardState[r][c];
      if (selected) {
        const found = legalMovesCache.find(m => m.to[0]===r && m.to[1]===c);
        if (found) {
          boardState = applyMove(boardState, found, 'white'); whiteToMove = !whiteToMove; selected = null; legalMovesCache = []; clearHighlights(); renderBoard(); setTimeout(()=> { if (!whiteToMove) runAIMove(); else { /* no-op */ } }, 180);
          // After player's move, check if game ended (no legal moves for opponent) will be handled in runAIMove
          return;
        }
        selected = null; clearHighlights();
      }

      if (piece && ((piece === piece.toUpperCase()) === whiteToMove)) {
        selected = {r,c}; legalMovesCache = generateMoves(boardState, whiteToMove).filter(m => m.from[0]===r && m.from[1]===c); clearHighlights(); this.classList.add('highlight'); highlightMoves(legalMovesCache);
      } else { selected = null; clearHighlights(); }
    }

    // initial render
    renderBoard(); const statusEl = document.getElementById('status'); statusEl.textContent = 'Your move â€” play White.'; statusEl.style.color = '#bdf7b8';

    // minimal placeholder buttons
    document.getElementById('connectWalletBtn').addEventListener('click', ()=> alert('Wallet connect placeholder (implement Web3 flow here).'));
    document.getElementById('createGameBtn').addEventListener('click', ()=> alert('Create game placeholder (matchmaking / on-chain game setup goes here).'));

    /* ------------------ Magic link firebase (keeps original dynamic load) ------------------ */
    document.getElementById('sendLinkBtn').addEventListener('click', async () => { const email = (document.getElementById('emailInput').value || '').trim(); if (!email) { alert('Please enter an email.'); return; } if (!window._firebaseReady) { alert('Attempting to load magic link support â€” if it fails, check console for errors.'); } window.localStorage.setItem('emailForSignIn', email); if (window._firebaseReady && window._sendSignInLinkToEmail) { try { await window._sendSignInLinkToEmail(email); alert('Magic link sent! Check your email and follow the link to sign in.'); } catch (err) { console.error(err); alert('Error sending magic link: ' + (err.message || err)); } } else { alert('Magic-link handler not available (firebase not loaded). Email saved locally for later.'); } });

    (async function loadFirebase() {
      try {
        const appMod = await import('https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js');
        const authMod = await import('https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js');
        const dbMod = await import('https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js');

        const firebaseConfig = { apiKey: "AIzaSyCiU4bLmbd5pJ6sv13TAMIk4eh8Exhid4o", authDomain: "sscwc-chess.firebaseapp.com", databaseURL: "https://sscwc-chess-default-rtdb.firebaseio.com", projectId: "sscwc-chess", storageBucket: "sscwc-chess.firebasestorage.app", messagingSenderId: "382398698085", appId: "1:382398698085:web:cc902f0f1b6b1b93602c8c" };
        const app = appMod.initializeApp(firebaseConfig);
        const auth = authMod.getAuth(app);
        const database = dbMod.getDatabase(app);

        window._firebaseReady = true;
        window._sendSignInLinkToEmail = async (email) => { const actionCodeSettings = { url: window.location.href, handleCodeInApp: true }; await authMod.sendSignInLinkToEmail(auth, email, actionCodeSettings); };

        authMod.onAuthStateChanged(auth, user => {
          if (user) { document.getElementById('status').textContent = 'Signed in as: ' + (user.email || 'anonymous'); document.getElementById('status').style.color = '#bdf7b8'; window._currentUser = user; }
          else { document.getElementById('status').textContent = 'Not signed in â€” enter email and click "Send Magic Link"'; document.getElementById('status').style.color = '#ccc'; window._currentUser = null; }
        });

        window._saveProfileStats = async (stats) => {
          if (!window._currentUser) return; try { const ref = dbMod.ref(database, 'profiles/' + window._currentUser.uid + '/stats'); await dbMod.set(ref, stats); } catch(e){ console.warn('saveProfileStats failed', e); }
        };

      } catch (err) { console.warn('Firebase dynamic import failed (UI remains usable):', err); const st = document.getElementById('status'); st.textContent = 'Firebase not loaded (magic link disabled) â€” board is still usable.'; st.style.color = '#ffd3a6'; }
    })();

    /* ------------------ Coach feedback analysis (lightweight heuristics) ------------------ */
    function analyzeOpening(history) {
      // look at first 12 ply (6 moves each) ~ first 8-12 moves as requested
      const ply = Math.min(history.length, 24);
      let developed = 0, castles = 0, centerControl = 0, badPawnMoves = 0;
      for (let i=0;i<ply;i++){
        const m = history[i]; if (!m) continue; const p = (m.piece||'').toLowerCase(); if (p==='n' || p==='b') developed++;
        if (m.castle) castles++;
        // center control heuristic: pawn moves to d4/e4/d5/e5 count
        const [tr,tc] = m.to; const file = tc; const rank = tr;
        // map to algebraic center squares roughly: ranks 3-4 (0-indexed): 3,4 and files 3,4
        if ((file===3 || file===4) && (rank===3 || rank===4)) centerControl++;
        // if a pawn moved from its start two times forward early, ok; but if many pawn moves by same side count as bad
        if (p==='p') { const from = m.from; if (Math.abs(m.to[0]-m.from[0])===0) badPawnMoves++; }
      }
      const msgs = [];
      if (developed >= 4) msgs.push('Great development â€” you brought out minors early.'); else msgs.push('Focus on developing knights & bishops in the opening.');
      if (castles>0) msgs.push('You castle â€” good king safety.'); else msgs.push('Try to castle earlier to secure the king.');
      if (centerControl >=2) msgs.push('Nice central control in the opening.'); else msgs.push('Try to occupy central squares (d4/e4).');
      return msgs;
    }

    function analyzeMiddlegame(history, board) {
      // simple heuristics: captures, piece activity (mobility), pawn structure
      const captures = history.filter(m=>m.capture).length;
      const mobility = (generateMoves(board,true).length + generateMoves(board,false).length)/2;
      const msgs = [];
      if (captures >=2) msgs.push('You engage in exchanges â€” this can be good if you simplify with advantage.'); else msgs.push('Look for tactical exchanges or combinations to gain material.');
      if (mobility > 25) msgs.push('Good piece activity â€” your pieces are active.'); else msgs.push('Increase piece activity: place rooks on open files and improve minor pieces.');
      return msgs;
    }

    function analyzeEndgame(history, board) {
      // look at last 30 ply
      const last = history.slice(-30);
      const msgs = [];
      // king activity heuristic: king rank for side to move
      // count rooks active
      let rookActivity = 0;
      for (let r=0;r<8;r++) for (let c=0;c<8;c++) { const p = board[r][c]; if (!p) continue; if (p.toLowerCase()==='r') { if ((p===p.toUpperCase() && r<6) || (p===p.toLowerCase() && r>1)) rookActivity++; } }
      if (rookActivity>0) msgs.push('Rook activity looks promising in the endgame.'); else msgs.push('Activate rooks in the endgame and use king as a fighting piece.');
      return msgs;
    }

    function composeCoachMessage() {
      const opening = analyzeOpening(moveHistory);
      const midd = analyzeMiddlegame(moveHistory, boardState);
      const endg = analyzeEndgame(moveHistory, boardState);
      const summary = [];
      summary.push('Game Summary');
      summary.push(opening.join(' '));
      summary.push(midd.join(' '));
      summary.push(endg.join(' '));
      return summary.join('\n\n');
    }

    function showCoachFeedback() {
      const msg = composeCoachMessage();
      // create modal
      const modal = document.createElement('div'); modal.className = 'coach-modal';
      const card = document.createElement('div'); card.className = 'coach-card';
      card.innerHTML = `<div class="coach-header"><div style="flex:1"><div class="coach-title">Post-game Coach Feedback</div><div class="small">Personalized analysis â€” training track & University progress</div></div><div><button class="close-x" id="coachCloseBtn">Close</button></div></div><div class="coach-body"><pre id="coachText" class="small" style="white-space:pre-wrap;font-family:inherit;margin-top:10px;">${escapeHtml(msg)}</pre><div class="coach-actions"><button class="btn btn-gold" id="coachSaveBtn">Save to Profile</button><button class="btn" id="coachDrillBtn">Open Suggested Drill</button></div></div>`;
      modal.appendChild(card); document.body.appendChild(modal);
      document.getElementById('coachCloseBtn').addEventListener('click', ()=> { modal.remove(); });
      document.getElementById('coachSaveBtn').addEventListener('click', async ()=> { if (window._saveProfileStats) { await window._saveProfileStats({ lastCoach: msg, lastPlayed: Date.now(), games: (aiGamesPlayed+1) }); alert('Saved to profile (if signed in).'); } else { alert('Profile save not available.'); } });
      document.getElementById('coachDrillBtn').addEventListener('click', ()=> { alert('Open drill placeholder â€” later link to targeted course content.'); });
    }

    function escapeHtml(text) { return (text+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    /* ------------------ Matchmaking trigger after 3 AI games + 10s priority offer ------------------ */
    function maybeTriggerMatchmaking() {
      if (aiGamesPlayed >= 3) {
        showMatchmakingOffer();
      }
    }

    function showMatchmakingOffer() {
      const modal = document.createElement('div'); modal.className = 'matchmaking-modal';
      const card = document.createElement('div'); card.className = 'matchmaking-card';
      card.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div><div style="font-weight:800;color:#ffd700;font-size:1.15rem">Priority Matchmaking</div><div class="small">Get matched faster with priority (USD-pegged fee)</div></div><div><button class="close-x" id="mmClose">Close</button></div></div><div style="margin-top:12px;text-align:left" class="small"><strong>Fee:</strong> <span id="feeAmount">$0.99 (USD)</span><br/><strong>Option:</strong> Pay priority or wait for AI-savings matchmaking.</div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button class="btn btn-gold" id="payPriority">Pay & Match Now</button><button class="btn" id="useAIsavings">AI-savings (wait)</button></div><div style="margin-top:12px;text-align:center" class="small">Auto-match in <span id="mmCountdown">10</span>s â€” choose an option to skip countdown.</div>`;
      modal.appendChild(card); document.body.appendChild(modal);
      let countdown = 10; const cdEl = document.getElementById('mmCountdown'); const intv = setInterval(()=>{ countdown--; cdEl.textContent = countdown; if (countdown<=0) { clearInterval(intv); modal.remove(); alert('AI-savings matchmaking started (placeholder).'); } },1000);
      document.getElementById('mmClose').addEventListener('click', ()=> { clearInterval(intv); modal.remove(); });
      document.getElementById('payPriority').addEventListener('click', ()=> { clearInterval(intv); modal.remove(); payPriorityMatch(); });
      document.getElementById('useAIsavings').addEventListener('click', ()=> { clearInterval(intv); modal.remove(); alert('AI-savings selected â€” you will be matched via lower-cost queue (placeholder).'); });
    }

    function payPriorityMatch() {
      alert('Priority payment placeholder â€” integrate BSC/Fiat on-ramp here. After successful payment, match will be attempted.');
    }

    /* ------------------ Track end of AI games to increment aiGamesPlayed ------------------ */
    // Wrap runAIMove to increment when an AI finishes a full game (we consider a full game when game ended or the AI delivers checkmate)
    // For simplicity we increase aiGamesPlayed each time the AI makes a move that results in mate/stalemate or when showCoachFeedback called after end.

    // Override showCoachFeedback to increment aiGamesPlayed when relevant
    const originalShowCoach = showCoachFeedback;
    window.__showCoachFeedback = function(){ originalShowCoach(); aiGamesPlayed++; maybeTriggerMatchmaking(); };

    // Replace calls to showCoachFeedback in code paths: we'll call window.__showCoachFeedback at game end
    // To ensure we call it, modify runAIMove earlier to call __showCoachFeedback when no aiMove
    // (We've already placed showCoachFeedback in runAIMove above) â€” so let's redefine runAIMove wrapper here:
    const _runAIMove = runAIMove;
    window.runAIMove = async function(){ await _runAIMove(); // after AI move, check game termination heuristics
      // if last move resulted in checkmate or stalemate, call coach wrapper
      const movesForSide = generateMoves(boardState, whiteToMove);
      if (movesForSide.length === 0) { // game ended
        window.__showCoachFeedback();
      }
    };

    // ensure earlier code uses window.runAIMove (on player move we call it)

    /* ------------------ Profile Dashboard (Full-screen Option 3) ------------------ */
    function openProfileDashboard() {
      const modal = document.createElement('div'); modal.className = 'profile-modal';
      const card = document.createElement('div'); card.className = 'profile-card';
      card.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div><div style="font-weight:900;color:#ffd700;font-size:1.25rem">Profile Dashboard</div><div class="small">Overview Â· Rewards Â· Achievements Â· University Track Â· Matchmaking Stats</div></div><div><button class="close-x" id="profileClose">Close</button></div></div>
        <div class="tabs">
          <div class="tab active" data-tab="overview">Overview</div>
          <div class="tab" data-tab="rewards">Rewards</div>
          <div class="tab" data-tab="achievements">Achievements</div>
          <div class="tab" data-tab="university">Certificates</div>
          <div class="tab" data-tab="matchstats">Matchmaking Stats</div>
          <div class="tab" data-tab="portfolio">Portfolio</div>
        </div>
        <div class="tab-panel" id="tabPanel">Loading...</div>`;
      modal.appendChild(card); document.body.appendChild(modal);
      document.getElementById('profileClose').addEventListener('click', ()=> { modal.remove(); });
      const tabs = card.querySelectorAll('.tab'); const panel = document.getElementById('tabPanel');
      tabs.forEach(t => t.addEventListener('click', ()=>{ tabs.forEach(x=>x.classList.remove('active')); t.classList.add('active'); const tabName = t.dataset.tab; renderTab(tabName, panel); }));
      renderTab('overview', panel);
    }

    function renderTab(name, panel) {
      if (name === 'overview') {
        panel.innerHTML = `<strong>Player Overview</strong><div class="small">Games played (AI): ${aiGamesPlayed}</div><div class="small">Last moves captured: ${moveHistory.length}</div><div style="margin-top:8px"><button class="btn btn-gold" id="exportProfile">Export Profile (JSON)</button></div>`;
        panel.querySelector('#exportProfile').addEventListener('click', ()=>{ const data = { aiGamesPlayed, moveHistory }; const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'sscwc_profile.json'; a.click(); URL.revokeObjectURL(url); });
      } else if (name === 'rewards') {
        panel.innerHTML = `<strong>Credits & Rewards</strong><div class="small">Credits: 120 (placeholder)</div><div class="small">Rebate tracking: 0.00 (placeholder)</div><div style="margin-top:8px"><button class="btn" onclick="alert('Redeem placeholder')">Redeem</button></div>`;
      } else if (name === 'achievements') {
        panel.innerHTML = `<strong>Achievements</strong><div class="small">No achievements yet â€” play games to unlock NFTs (placeholders).</div>`;
      } else if (name === 'university') {
        panel.innerHTML = `<strong>Certificates / University Track</strong><div class="small">Progress: Beginner â†’ Intermediate (placeholder)</div><div style="margin-top:8px"><button class="btn" onclick="alert('Open course placeholder')">Open eMBA course</button></div>`;
      } else if (name === 'matchstats') {
        panel.innerHTML = `<strong>Matchmaking Stats</strong><div class="small">Priority matches used: 0</div><div class="small">Typical match wait: 12s (placeholder)</div>`;
      } else if (name === 'portfolio') {
        panel.innerHTML = `<strong>Financial Portfolio</strong><div class="small">SSCWC balance: 0.0 (placeholder)</div><div class="small">USD value (peg): $0.00</div>`;
      }
    }

    document.getElementById('openProfileBtn').addEventListener('click', openProfileDashboard);

    /* ------------------ Small helpers & wiring for match trigger after 3 AI games ------------------ */
    // When the AI delivers a mate/stalemate we call window.__showCoachFeedback which increments aiGamesPlayed and maybe triggers matchmaking.

    // Expose some functions for testing in console
    window.__TEST = { moveHistory, getCoach: composeCoachMessage, getAIplays: ()=>aiGamesPlayed };

  </script>
</body>
</html>
